ðŸ“š Data Structures & Algorithms â€“ Complete Roadmap
ðŸ”° PREREQUISITES (Before Starting DSA)

 Java Basics

 Variables

 Data Types

 Loops

 Conditionals

 Functions

 Parameters

 Return Types

 Static vs Non-static

 Object-Oriented Programming (OOP)

 Classes & Objects

 Inheritance

 Polymorphism

 Encapsulation

 Abstraction

 Constructors

 this keyword

 super keyword

 Packages

 Access Modifiers

 Exception Handling

 Java Collections Framework Basics

 Java Collections Framework Overview

 Mathematical Concepts

 Number Systems

 GCD

 LCM

 Prime Numbers

 Logarithms

 Modular Arithmetic

 Bitwise Operations (&, |, ^, ~, >>, <<)

 Recurrence Relations

 Exponentiation

 Complexity Analysis

 Time Complexity (Big O, Î©, Î˜)

 Space Complexity

 Asymptotic Analysis

 Recurrence Relations

 Masterâ€™s Theorem

ðŸ§± 1. DATA STRUCTURES (Core DS)

 1.1 Arrays

 Basics and Operations (Insert, Delete, Traverse)

 Searching Algorithms

 Sorting Algorithms

 Binary Search

 Merge Sort

 Quick Sort

 Two Pointer Technique

 Sliding Window Technique

 Prefix Sum

 Kadaneâ€™s Algorithm (Maximum Subarray Sum)

 Array Rotations

 Rearrangements

 Leaders in Array

 Subarray Problems (Sum, Product, Modulo)

 1.2 Strings

 String Creation & Immutability in Java

 StringBuilder

 StringBuffer

 Pattern Searching (Naive)

 KMP Algorithm

 Rabin-Karp Algorithm

 Anagram Checking

 Palindrome Checking

 Substring Generation

 Subsequence Generation

 String Hashing

 Rolling Hash

 Character Frequency Problems

 1.3 Linked List

 Singly Linked List (Insert, Delete, Begin, Display)

 Doubly Linked List

 Circular Linked List

 Detect Loop (Floydâ€™s Algorithm)

 Remove Loop

 Merge Two Sorted Linked Lists

 Intersection Point of Two Linked Lists

 Copy Linked List with Random Pointer

 1.4 Stack

 Stack Implementation using Array

 Stack Implementation using Linked List

 Infix to Postfix Conversion

 Infix to Prefix Conversion

 Balanced Parentheses

 Next Greater Element

 Stock Span Problem

 Histogram Maximum Area

 Min Stack Implementation

 1.5 Queue

 Queue Implementation using Array

 Queue Implementation using Linked List

 Circular Queue

 Deque (Double Ended Queue)

 Priority Queue (Min Heap / Max Heap)

 Sliding Window Maximum

 Queue using Stack

 Stack using Queue

 BFS Applications

 1.6 Recursion & Backtracking

 Base Case & Recursive Case

 Factorial

 Fibonacci

 Power Function

 Subsets

 Permutations

 Combinations

 N-Queens

 Sudoku Solver

 Rat in a Maze

 Word Search

 Combination Sum

 Recursion Tree

 Memoization Introduction

 1.7 Trees

 Binary Tree Basics

 Inorder Traversal

 Preorder Traversal

 Postorder Traversal

 Level Order Traversal

 Height of Tree

 Diameter of Tree

 Leaf Nodes

 Sum of Nodes

 Binary Search Tree

 BST Insertion

 BST Deletion

 BST Searching

 Check if Valid BST

 Lowest Common Ancestor

 Balanced Binary Tree (AVL Basics)

 Boundary Traversal

 Vertical Order Traversal

 Top View

 Bottom View

 Convert Tree to DLL

 1.8 Heap

 Min Heap

 Max Heap

 Build Heap from Array

 Heapify Operation

 Heap Sort

 Kth Smallest Element

 Kth Largest Element

 Merge K Sorted Arrays / Lists

 Median of Running Stream

 1.9 Hashing

 HashMap

 HashSet

 Hashing Concepts & Collisions

 Frequency Counting

 Subarray Sum Equals K

 Two Sum

 Count Distinct Elements in Window

 Longest Consecutive Subsequence

 1.10 Graphs

 Graph Representation (Adjacency List)

 Graph Representation (Adjacency Matrix)

 BFS

 DFS

 Connected Components (Undirected Graph)

 Directed Graph Traversal

 Topological Sort (Kahnâ€™s Algorithm)

 Dijkstraâ€™s Algorithm

 Bellman-Ford Algorithm

 Floyd-Warshall Algorithm

 Kruskalâ€™s Algorithm

 Primâ€™s Algorithm

 Detect Cycle (Directed)

 Detect Cycle (Undirected)

 Bipartite Graph Check

 Kosaraju Algorithm

 Tarjan Algorithm

 Graph Coloring

 Disjoint Set Union (Path Compression)

 1.11 Advanced Trees

 Segment Tree

 Fenwick Tree (Binary Indexed Tree)

 Trie (Prefix Tree)

 Suffix Tree

 Suffix Array

 AVL Tree

 Red-Black Tree

âš™ï¸ 2. ALGORITHMS

 2.1 Sorting Algorithms

 Bubble Sort

 Selection Sort

 Insertion Sort

 Merge Sort

 Quick Sort

 Heap Sort

 Counting Sort

 Radix Sort

 Bucket Sort

 2.2 Searching Algorithms

 Linear Search

 Binary Search

 Binary Search on Answer

 Ternary Search

 2.3 Divide and Conquer

 Merge Sort

 Quick Sort

 Binary Search Applications

 Closest Pair of Points

 Strassenâ€™s Matrix Multiplication

 2.4 Greedy Algorithms

 Activity Selection

 Fractional Knapsack

 Huffman Coding

 Job Sequencing with Deadlines

 Minimum Spanning Tree

 Dijkstraâ€™s Algorithm

 Greedy Scheduling

 2.5 Dynamic Programming

 Memoization

 Tabulation

 Fibonacci

 Climbing Stairs

 House Robber

 Grid Paths

 Minimum Path Sum

 Unique Paths

 0/1 Knapsack

 Unbounded Knapsack

 Subset Sum

 Longest Common Subsequence

 Longest Palindromic Subsequence

 Edit Distance

 Partition DP

 DP on Trees

 Bitmask DP

 Digit DP

 2.6 Backtracking & Recursion (Advanced)

 N-Queens

 Rat in a Maze

 Sudoku Solver

 Subset Generation

 Permutation Generation

 Palindrome Partitioning

 Word Break

 Hamiltonian Path

 Hamiltonian Cycle

 2.7 Bit Manipulation

 Bitwise Operators

 Even/Odd Check

 Set & Unset Bits

 Counting Bits (Brian Kernighan)

 Subsets using Bits

 Power of Two Check

 XOR Properties

ðŸ§  3. ADVANCED TOPICS

 3.1 Advanced Graphs

 0â€“1 BFS

 Dialâ€™s Algorithm

 Bridges

 Articulation Points

 Euler Tour

 Hamiltonian Cycle

 Fordâ€“Fulkerson Algorithm

 Edmondsâ€“Karp Algorithm

 Push-Relabel Algorithm

 3.2 Advanced Data Structures

 Trie

 Segment Tree

 Fenwick Tree

 Disjoint Set Union

 Sparse Table (RMQ)

 3.3 Computational Geometry

 Convex Hull (Graham Scan)

 Line Intersection

 Rotating Calipers

 3.4 Advanced String Algorithms

 KMP Algorithm

 Z-Function

 Rabin-Karp

 Longest Prefix Suffix (LPS)

 Trie for Word Search

 Suffix Array

 Suffix Tree

 Rolling Hash

ðŸŽ¯ Goal: Master DSA comple
